import os
import json
import itertools
import numpy as np
from tqdm import tqdm
from typing import List, Dict, Union, Optional
from collections import defaultdict
from concurrent.futures import ThreadPoolExecutor, as_completed

from .base import BaseDataset, DATA_PATH

CRYPTO_TRADE_FILE = "CryptoTrade.jsonl"

class CryptoTradeDataset(BaseDataset):

    def __init__(self):
        """
        Initializes a dataset instance for CryptoTrader, loading data from a JSON file specified in the configuration.
        """
        data_file = os.path.join(DATA_PATH, "crypto_trade", CRYPTO_TRADE_FILE)
        data = self.load(data_file)
        super().__init__(data)

        self.metric_name = "profit"
        self.metric_description = "The profit generated by the agent's trade actions. Higher values are better."

    def __getitem__(self, idx: int) -> Dict:
        """
        Retrieve a trading scenario by its index.

        Args:
            idx (int): The index of the scenario.

        Returns:
            Dict: The trading scenario details.
        """
        return self.data[idx]

    def get_case_dict(self, idx: int):
        """
        Create a dictionary representing a case at a specific index, including the ground truth if available.

        Args:
            idx (int): The index of the case.

        Returns:
            Dict[str, Any]: A dictionary with case details.
        """
        return {
            "case_id": self.data[idx]["trade_id"],
            "case_name": self.data[idx]["trade_id"],
            "task_id": "crypto_trade",
            "input": {
                "market_data": self.data[idx]["market_data"],
                "initial_balance": self.data[idx]["initial_balance"],
            },
            "ground_truth": self.data[idx].get("expected_profit"),
            "idx": idx,
            "metric_name": self.metric_name,
            "metric_description": self.metric_description,
        }

    def to_dict(self):
        """
        Convert the dataset to a dictionary using trade IDs as keys.

        Returns:
            Dict[str, Dict[str, Any]]: A dictionary mapping trade IDs to their corresponding data points.
        """
        return {data_point["trade_id"]: data_point for data_point in self.data}

    def evaluate(self, idx: int, actions: List[Dict]) -> Dict:
        """
        Evaluate the correctness of the agent's trading actions against the ground truth.

        Args:
            idx (int): The index of the trading scenario.
            actions (List[Dict]): The trading actions to evaluate.

        Returns:
            Dict: A dictionary containing the evaluation results.
        """
        scenario = self.data[idx]
        actual_profit = self.simulate_trades(scenario, actions)
        expected_profit = scenario.get("expected_profit", None)

        return {
            "trade_id": scenario["trade_id"],
            "actual_profit": actual_profit,
            "expected_profit": expected_profit,
            "success": actual_profit >= expected_profit if expected_profit is not None else None,
        }

    def simulate_trades(self, scenario: Dict, actions: List[Dict]) -> float:
        """
        Simulate the trades based on the agent's actions and calculate profit.

        Args:
            scenario (Dict): The trading scenario details.
            actions (List[Dict]): The agent's trading actions.

        Returns:
            float: The profit generated by the actions.
        """
        balance = scenario["initial_balance"]
        market_data = scenario["market_data"]

        for action in actions:
            if action["type"] == "buy":
                balance -= action["amount"] * market_data[action["timestamp"]]["price"]
            elif action["type"] == "sell":
                balance += action["amount"] * market_data[action["timestamp"]]["price"]

        return balance - scenario["initial_balance"]

    def overall_evaluate(
        self,
        sample_file: str,
        n_workers: int = 4,
    ) -> Dict:
        """
        Evaluate the agent's performance across all trading scenarios.

        Args:
            sample_file (str): Path to the file containing sample agent actions.
            n_workers (int): Number of workers to use for parallel evaluation.

        Returns:
            Dict: Aggregated evaluation results.
        """
        with open(sample_file, "r", encoding="utf-8") as f:
            sample_data = [json.loads(line) for line in f]

        scenarios = self.to_dict()
        results = defaultdict(list)

        with ThreadPoolExecutor(max_workers=n_workers) as executor:
            futures = []
            for sample in tqdm(sample_data, desc="Submitting tasks"):
                trade_id = sample["trade_id"]
                scenario = scenarios[trade_id]
                actions = sample["actions"]
                future = executor.submit(self.evaluate, scenario["idx"], actions)
                futures.append(future)

            for future in tqdm(as_completed(futures), total=len(futures), desc="Evaluating tasks"):
                result = future.result()
                results[result["trade_id"]].append(result)

        aggregated_results = {
            "total_scenarios": len(results),
            "successful_trades": sum(r["success"] for res in results.values() for r in res if r["success"] is not None),
            "average_profit": np.mean([r["actual_profit"] for res in results.values() for r in res]),
        }

        return aggregated_results
